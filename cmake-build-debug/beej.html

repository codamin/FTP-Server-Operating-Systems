  Beej's Guide to Network Programming


    Using Internet Sockets

*Brian "Beej Jorgensen" Hall*
beej@beej.us <mailto:beej@beej.us>

Version 3.0.21
June 8, 2016

Copyright © 2015 Brian "Beej Jorgensen" Hall

------------------------------------------------------------------------


    Contents

------------------------------------------------------------------------

1. Intro <#intro>
    1.1. Audience <#audience>
    1.2. Platform and Compiler <#platform>
    1.3. Official Homepage and Books For Sale <#homepage>
    1.4. Note for Solaris/SunOS Programmers <#solaris>
    1.5. Note for Windows Programmers <#windows>
    1.6. Email Policy <#emailpolicy>
    1.7. Mirroring <#mirroring>
    1.8. Note for Translators <#xlate>
    1.9. Copyright and Distribution <#copyright>

2. What is a socket? <#theory>
    2.1. Two Types of Internet Sockets <#twotypes>
    2.2. Low level Nonsense and Network Theory <#lowlevel>

3. IP Addresses, structs, and Data Munging <#ipstructsdata>
    3.1. IP Addresses, versions 4 and 6 <#ipaddrs1>
    3.2. Byte Order <#byteorder>
    3.3. structs <#structs>
    3.4. IP Addresses, Part Deux <#ipaddrs2>

4. Jumping from IPv4 to IPv6 <#ip4to6>

5. System Calls or Bust <#syscalls>
    5.1. *getaddrinfo()*—Prepare to launch! <#getaddrinfo>
    5.2. *socket()*—Get the File Descriptor! <#socket>
    5.3. *bind()*—What port am I on? <#bind>
    5.4. *connect()*—Hey, you! <#connect>
    5.5. *listen()*—Will somebody please call me? <#listen>
    5.6. *accept()*—"Thank you for calling port 3490." <#accept>
    5.7. *send()* and *recv()*—Talk to me, baby! <#sendrecv>
    5.8. *sendto()* and *recvfrom()*—Talk to me, DGRAM-style <#sendtorecv>
    5.9. *close()* and *shutdown()*—Get outta my face! <#closedown>
    5.10. *getpeername()*—Who are you? <#getpeername>
    5.11. *gethostname()*—Who am I? <#gethostname>

6. Client-Server Background <#clientserver>
    6.1. A Simple Stream Server <#simpleserver>
    6.2. A Simple Stream Client <#simpleclient>
    6.3. Datagram Sockets <#datagram>

7. Slightly Advanced Techniques <#advanced>
    7.1. Blocking <#blocking>
    7.2. *select()*—Synchronous I/O Multiplexing <#select>
    7.3. Handling Partial *send()*s <#sendall>
    7.4. Serialization—How to Pack Data <#serialization>
    7.5. Son of Data Encapsulation <#sonofdataencap>
    7.6. Broadcast Packets—Hello, World! <#broadcast>

8. Common Questions <#faq>

9. Man Pages <#man>
    9.1. *accept()* <#acceptman>
    9.2. *bind()* <#bindman>
    9.3. *connect()* <#connectman>
    9.4. *close()* <#closeman>
    9.5. *getaddrinfo()*, *freeaddrinfo()*, *gai_strerror()*
    <#getaddrinfoman>
    9.6. *gethostname()* <#gethostnameman>
    9.7. *gethostbyname()*, *gethostbyaddr()* <#gethostbynameman>
    9.8. *getnameinfo()* <#getnameinfoman>
    9.9. *getpeername()* <#getpeernameman>
    9.10. /errno/ <#errnoman>
    9.11. *fcntl()* <#fcntlman>
    9.12. *htons()*, *htonl()*, *ntohs()*, *ntohl()* <#htonsman>
    9.13. *inet_ntoa()*, *inet_aton()*, *inet_addr* <#inet_ntoaman>
    9.14. *inet_ntop()*, *inet_pton()* <#inet_ntopman>
    9.15. *listen()* <#listenman>
    9.16. *perror()*, *strerror()* <#perrorman>
    9.17. *poll()* <#pollman>
    9.18. *recv()*, *recvfrom()* <#recvman>
    9.19. *select()* <#selectman>
    9.20. *setsockopt()*, *getsockopt()* <#setsockoptman>
    9.21. *send()*, *sendto()* <#sendman>
    9.22. *shutdown()* <#shutdownman>
    9.23. *socket()* <#socketman>
    9.24. struct sockaddr and pals <#sockaddr_inman>

10. More References <#reference>
    10.1. Books <#books>
    10.2. Web References <#webref>
    10.3. RFCs <#rfcs>

Index <#zindex>

------------------------------------------------------------------------


    1. Intro

------------------------------------------------------------------------

Hey! Socket programming got you down? Is this stuff just a little too
difficult to figure out from the *man* pages? You want to do cool
Internet programming, but you don't have time to wade through a gob of
structs trying to figure out if you have to call *bind()* before you
*connect()*, etc., etc.

Well, guess what! I've already done this nasty business, and I'm dying
to share the information with everyone! You've come to the right place.
This document should give the average competent C programmer the edge
s/he needs to get a grip on this networking noise.

And check it out: I've finally caught up with the future (just in the
nick of time, too!) and have updated the Guide for IPv6! Enjoy!


      1.1. Audience

This document has been written as a tutorial, not a complete reference.
It is probably at its best when read by individuals who are just
starting out with socket programming and are looking for a foothold. It
is certainly not the /complete and total/ guide to sockets programming,
by any means.

Hopefully, though, it'll be just enough for those man pages to start
making sense... :-)


      1.2. Platform and Compiler

The code contained within this document was compiled on a Linux PC using
Gnu's *gcc* compiler. It should, however, build on just about any
platform that uses *gcc*. Naturally, this doesn't apply if you're
programming for Windows—see the section on Windows programming
<#windows>, below.


      1.3. Official Homepage and Books For Sale

This official location of this document is http://beej.us/guide/bgnet/.
There you will also find example code and translations of the guide into
various languages.

To buy nicely bound print copies (some call them "books"), visit
http://beej.us/guide/url/bgbuy. I'll appreciate the purchase because it
helps sustain my document-writing lifestyle!


      1.4. Note for Solaris/SunOS Programmers

When compiling for Solaris or SunOS, you need to specify some extra
command-line switches for linking in the proper libraries. In order to
do this, simply add "-lnsl -lsocket -lresolv" to the end of the compile
command, like so:

$ cc -o server server.c -lnsl -lsocket -lresolv

If you still get errors, you could try further adding a "-lxnet" to the
end of that command line. I don't know what that does, exactly, but some
people seem to need it.

Another place that you might find problems is in the call to
*setsockopt()*. The prototype differs from that on my Linux box, so
instead of:

int yes=1;

enter this:

char yes='1';

As I don't have a Sun box, I haven't tested any of the above
information—it's just what people have told me through email.


      1.5. Note for Windows Programmers

At this point in the guide, historically, I've done a bit of bagging on
Windows, simply due to the fact that I don't like it very much. But I
should really be fair and tell you that Windows has a huge install base
and is obviously a perfectly fine operating system.

They say absence makes the heart grow fonder, and in this case, I
believe it to be true. (Or maybe it's age.) But what I can say is that
after a decade-plus of not using Microsoft OSes for my personal work,
I'm much happier! As such, I can sit back and safely say, "Sure, feel
free to use Windows!" ...Ok yes, it does make me grit my teeth to say that.

So I still encourage you to try Linux <http://www.linux.com/>, BSD
<http://www.bsd.org/>, or some flavor of Unix, instead.

But people like what they like, and you Windows folk will be pleased to
know that this information is generally applicable to you guys, with a
few minor changes, if any.

One cool thing you can do is install Cygwin <http://www.cygwin.com/>,
which is a collection of Unix tools for Windows. I've heard on the
grapevine that doing so allows all these programs to compile unmodified.

But some of you might want to do things the Pure Windows Way. That's
very gutsy of you, and this is what you have to do: run out and get Unix
immediately! No, no—I'm kidding. I'm supposed to be Windows-friendly(er)
these days...

This is what you'll have to do (unless you install Cygwin
<http://www.cygwin.com/>!): first, ignore pretty much all of the system
header files I mention in here. All you need to include is:

#include <winsock.h>

Wait! You also have to make a call to *WSAStartup()* before doing
anything else with the sockets library. The code to do that looks
something like this:

#include <winsock.h>

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:

    if (WSAStartup(MAKEWORD(1,1), &wsaData) != 0) {
        fprintf(stderr, "WSAStartup failed.\n");
        exit(1);
    }

You also have to tell your compiler to link in the Winsock library,
usually called /wsock32.lib/ or /winsock32.lib/, or /ws2_32.lib/ for
Winsock 2.0. Under VC++, this can be done through the Project menu,
under Settings.... Click the Link tab, and look for the box titled
"Object/library modules". Add "wsock32.lib" (or whichever lib is your
preference) to that list.

Or so I hear.

Finally, you need to call *WSACleanup()* when you're all through with
the sockets library. See your online help for details.

Once you do that, the rest of the examples in this tutorial should
generally apply, with a few exceptions. For one thing, you can't use
*close()* to close a socket—you need to use *closesocket()*, instead.
Also, *select()* only works with socket descriptors, not file
descriptors (like 0 for stdin).

There is also a socket class that you can use, CSocket. Check your
compilers help pages for more information.

To get more information about Winsock, read the Winsock FAQ
<http://tangentsoft.net/wskfaq/> and go from there.

Finally, I hear that Windows has no *fork()* system call which is,
unfortunately, used in some of my examples. Maybe you have to link in a
POSIX library or something to get it to work, or you can use
*CreateProcess()* instead. *fork()* takes no arguments, and
*CreateProcess()* takes about 48 billion arguments. If you're not up to
that, the *CreateThread()* is a little easier to digest...unfortunately
a discussion about multithreading is beyond the scope of this document.
I can only talk about so much, you know!


      1.6. Email Policy

I'm generally available to help out with email questions so feel free to
write in, but I can't guarantee a response. I lead a pretty busy life
and there are times when I just can't answer a question you have. When
that's the case, I usually just delete the message. It's nothing
personal; I just won't ever have the time to give the detailed answer
you require.

As a rule, the more complex the question, the less likely I am to
respond. If you can narrow down your question before mailing it and be
sure to include any pertinent information (like platform, compiler,
error messages you're getting, and anything else you think might help me
troubleshoot), you're much more likely to get a response. For more
pointers, read ESR's document, How To Ask Questions The Smart Way
<http://www.catb.org/~esr/faqs/smart-questions.html>.

If you don't get a response, hack on it some more, try to find the
answer, and if it's still elusive, then write me again with the
information you've found and hopefully it will be enough for me to help out.

Now that I've badgered you about how to write and not write me, I'd just
like to let you know that I /fully/ appreciate all the praise the guide
has received over the years. It's a real morale boost, and it gladdens
me to hear that it is being used for good! :-) Thank you!


      1.7. Mirroring

You are more than welcome to mirror this site, whether publicly or
privately. If you publicly mirror the site and want me to link to it
from the main page, drop me a line at beej@beej.us <mailto:beej@beej.us>.


      1.8. Note for Translators

If you want to translate the guide into another language, write me at
beej@beej.us <mailto:beej@beej.us> and I'll link to your translation
from the main page. Feel free to add your name and contact info to the
translation.

Please note the license restrictions in the Copyright and Distribution
section, below.

If you want me to host the translation, just ask. I'll also link to it
if you want to host it; either way is fine.


      1.9. Copyright and Distribution

Beej's Guide to Network Programming is Copyright © 2015 Brian "Beej
Jorgensen" Hall.

With specific exceptions for source code and translations, below, this
work is licensed under the Creative Commons Attribution- Noncommercial-
No Derivative Works 3.0 License. To view a copy of this license, visit
http://creativecommons.org/licenses/by-nc-nd/3.0/ or send a letter to
Creative Commons, 171 Second Street, Suite 300, San Francisco,
California, 94105, USA.

One specific exception to the "No Derivative Works" portion of the
license is as follows: this guide may be freely translated into any
language, provided the translation is accurate, and the guide is
reprinted in its entirety. The same license restrictions apply to the
translation as to the original guide. The translation may also include
the name and contact information for the translator.

The C source code presented in this document is hereby granted to the
public domain, and is completely free of any license restriction.

Educators are freely encouraged to recommend or supply copies of this
guide to their students.

Contact beej@beej.us <mailto:beej@beej.us> for more information.

------------------------------------------------------------------------


    2. What is a socket?

------------------------------------------------------------------------

You hear talk of "sockets" all the time, and perhaps you are wondering
just what they are exactly. Well, they're this: a way to speak to other
programs using standard Unix file descriptors.

What?

Ok—you may have heard some Unix hacker state, "Jeez, /everything/ in
Unix is a file!" What that person may have been talking about is the
fact that when Unix programs do any sort of I/O, they do it by reading
or writing to a file descriptor. A file descriptor is simply an integer
associated with an open file. But (and here's the catch), that file can
be a network connection, a FIFO, a pipe, a terminal, a real on-the-disk
file, or just about anything else. Everything in Unix /is/ a file! So
when you want to communicate with another program over the Internet
you're gonna do it through a file descriptor, you'd better believe it.

"Where do I get this file descriptor for network communication, Mr.
Smarty-Pants?" is probably the last question on your mind right now, but
I'm going to answer it anyway: You make a call to the *socket()* system
routine. It returns the socket descriptor, and you communicate through
it using the specialized *send()* and *recv()* (*man send <#sendman>*,
*man recv <#recvman>*) socket calls.

"But, hey!" you might be exclaiming right about now. "If it's a file
descriptor, why in the name of Neptune can't I just use the normal
*read()* and *write()* calls to communicate through the socket?" The
short answer is, "You can!" The longer answer is, "You can, but *send()*
and *recv()* offer much greater control over your data transmission."

What next? How about this: there are all kinds of sockets. There are
DARPA Internet addresses (Internet Sockets), path names on a local node
(Unix Sockets), CCITT X.25 addresses (X.25 Sockets that you can safely
ignore), and probably many others depending on which Unix flavor you
run. This document deals only with the first: Internet Sockets.


      2.1. Two Types of Internet Sockets

What's this? There are two types of Internet sockets? Yes. Well, no. I'm
lying. There are more, but I didn't want to scare you. I'm only going to
talk about two types here. Except for this sentence, where I'm going to
tell you that "Raw Sockets" are also very powerful and you should look
them up.

All right, already. What are the two types? One is "Stream Sockets"; the
other is "Datagram Sockets", which may hereafter be referred to as
"SOCK_STREAM" and "SOCK_DGRAM", respectively. Datagram sockets are
sometimes called "connectionless sockets". (Though they can be
*connect()*'d if you really want. See *connect() <#connect>*, below.)

Stream sockets are reliable two-way connected communication streams. If
you output two items into the socket in the order "1, 2", they will
arrive in the order "1, 2" at the opposite end. They will also be
error-free. I'm so certain, in fact, they will be error-free, that I'm
just going to put my fingers in my ears and chant /la la la la/ if
anyone tries to claim otherwise.

What uses stream sockets? Well, you may have heard of the *telnet*
application, yes? It uses stream sockets. All the characters you type
need to arrive in the same order you type them, right? Also, web
browsers use the HTTP protocol which uses stream sockets to get pages.
Indeed, if you telnet to a web site on port 80, and type "GET /
HTTP/1.0" and hit RETURN twice, it'll dump the HTML back at you!

How do stream sockets achieve this high level of data transmission
quality? They use a protocol called "The Transmission Control Protocol",
otherwise known as "TCP" (see RFC 793
<http://tools.ietf.org/html/rfc793> for extremely detailed info on TCP.)
TCP makes sure your data arrives sequentially and error-free. You may
have heard "TCP" before as the better half of "TCP/IP" where "IP" stands
for "Internet Protocol" (see RFC 791
<http://tools.ietf.org/html/rfc791>.) IP deals primarily with Internet
routing and is not generally responsible for data integrity.

Cool. What about Datagram sockets? Why are they called connectionless?
What is the deal, here, anyway? Why are they unreliable? Well, here are
some facts: if you send a datagram, it may arrive. It may arrive out of
order. If it arrives, the data within the packet will be error-free.

Datagram sockets also use IP for routing, but they don't use TCP; they
use the "User Datagram Protocol", or "UDP" (see RFC 768
<http://tools.ietf.org/html/rfc768>.)

Why are they connectionless? Well, basically, it's because you don't
have to maintain an open connection as you do with stream sockets. You
just build a packet, slap an IP header on it with destination
information, and send it out. No connection needed. They are generally
used either when a TCP stack is unavailable or when a few dropped
packets here and there don't mean the end of the Universe. Sample
applications: *tftp* (trivial file transfer protocol, a little brother
to FTP), *dhcpcd* (a DHCP client), multiplayer games, streaming audio,
video conferencing, etc.

"Wait a minute! *tftp* and *dhcpcd* are used to transfer binary
applications from one host to another! Data can't be lost if you expect
the application to work when it arrives! What kind of dark magic is this?"

Well, my human friend, *tftp* and similar programs have their own
protocol on top of UDP. For example, the tftp protocol says that for
each packet that gets sent, the recipient has to send back a packet that
says, "I got it!" (an "ACK" packet.) If the sender of the original
packet gets no reply in, say, five seconds, he'll re-transmit the packet
until he finally gets an ACK. This acknowledgment procedure is very
important when implementing reliable SOCK_DGRAM applications.

For unreliable applications like games, audio, or video, you just ignore
the dropped packets, or perhaps try to cleverly compensate for them.
(Quake players will know the manifestation this effect by the technical
term: /accursed lag/. The word "accursed", in this case, represents any
extremely profane utterance.)

Why would you use an unreliable underlying protocol? Two reasons: speed
and speed. It's way faster to fire-and-forget than it is to keep track
of what has arrived safely and make sure it's in order and all that. If
you're sending chat messages, TCP is great; if you're sending 40
positional updates per second of the players in the world, maybe it
doesn't matter so much if one or two get dropped, and UDP is a good choice.


      2.2. Low level Nonsense and Network Theory

Since I just mentioned layering of protocols, it's time to talk about
how networks really work, and to show some examples of how SOCK_DGRAM
packets are built. Practically, you can probably skip this section. It's
good background, however.

[Encapsulated Protocols Diagram]

*Data Encapsulation.*

Hey, kids, it's time to learn about /Data Encapsulation <#figure1>/!
This is very very important. It's so important that you might just learn
about it if you take the networks course here at Chico State ;-).
Basically, it says this: a packet is born, the packet is wrapped
("encapsulated") in a header (and rarely a footer) by the first protocol
(say, the TFTP protocol), then the whole thing (TFTP header included) is
encapsulated again by the next protocol (say, UDP), then again by the
next (IP), then again by the final protocol on the hardware (physical)
layer (say, Ethernet).

When another computer receives the packet, the hardware strips the
Ethernet header, the kernel strips the IP and UDP headers, the TFTP
program strips the TFTP header, and it finally has the data.

Now I can finally talk about the infamous /Layered Network Model/ (aka
"ISO/OSI"). This Network Model describes a system of network
functionality that has many advantages over other models. For instance,
you can write sockets programs that are exactly the same without caring
how the data is physically transmitted (serial, thin Ethernet, AUI,
whatever) because programs on lower levels deal with it for you. The
actual network hardware and topology is transparent to the socket
programmer.

Without any further ado, I'll present the layers of the full-blown
model. Remember this for network class exams:

  * Application
  * Presentation
  * Session
  * Transport
  * Network
  * Data Link
  * Physical

The Physical Layer is the hardware (serial, Ethernet, etc.). The
Application Layer is just about as far from the physical layer as you
can imagine—it's the place where users interact with the network.

Now, this model is so general you could probably use it as an automobile
repair guide if you really wanted to. A layered model more consistent
with Unix might be:

  * Application Layer (/telnet, ftp, etc./)
  * Host-to-Host Transport Layer (/TCP, UDP/)
  * Internet Layer (/IP and routing/)
  * Network Access Layer (/Ethernet, wi-fi, or whatever/)

At this point in time, you can probably see how these layers correspond
to the encapsulation of the original data.

See how much work there is in building a simple packet? Jeez! And you
have to type in the packet headers yourself using "*cat*"! Just kidding.
All you have to do for stream sockets is *send()* the data out. All you
have to do for datagram sockets is encapsulate the packet in the method
of your choosing and *sendto()* it out. The kernel builds the Transport
Layer and Internet Layer on for you and the hardware does the Network
Access Layer. Ah, modern technology.

So ends our brief foray into network theory. Oh yes, I forgot to tell
you everything I wanted to say about routing: nothing! That's right, I'm
not going to talk about it at all. The router strips the packet to the
IP header, consults its routing table, blah blah blah. Check out the IP
RFC <http://tools.ietf.org/html/rfc791> if you really really care. If
you never learn about it, well, you'll live.

------------------------------------------------------------------------


    3. IP Addresses, *struct*s, and Data Munging

------------------------------------------------------------------------

Here's the part of the game where we get to talk code for a change.